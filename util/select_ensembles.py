#!/usr/bin/env python
r'''
select_ensembles.py: select from a list of simulation-ensembles

usage:
  select_ensembles.py [-q] [-0] [-S] [-n N] [-k key] [-o key] MODE CSVFILE

where:
  MODE is "top", "bottom", or "mix"
  CSVFILE is a CSV file containing yields and experiment names
     (it is as generated by reduce-drms.py)
and:
  -n N tells how many rows to select.  Default is 10.  Non-negative, or T for all rows.
  -k key gives the "value key" to use for "top", "bottom", or "mix".  Default is first key.
  -o key gives the "output key" which is printed to stdout
  -S means to use Sandbox filename conventions to get CSVFILE
  -0 means to use \0 as the item separator for output keys
  -t THRESH means to output only records where the value key is <= THRESH
  -T THRESH means to output only records where the value key is > THRESH
  -q means to exit quietly if CSVFILE is not present

The interpretation of MODE is:
  top (bottom): select the rows containing the top (resp. bottom) N values of KEY, 
    with values compared numerically if possible, and alphabetically otherwise.
  mix: select an arbitrary mix of N rows, with the rows selected according to the
    md5 hash of the value of KEY.  This provides stability across invocations if 
    rows are added to the CSVFILE between runs, provided the KEY is unchanged.

For simplicity, giving [-S] flags that the csv file will be derived using
the directory named in CSVFILE, and sandbox conventions ("reduce-info.csv" for
an Ensemble, and "reduce-yield-plus.csv" for .exp/.fam).

If you want to select all records with value key no more than 2, use
"-t 2 -n T", so that there is no upper limit on the number of keys selected.

In addition, the pseudokey _index (for -k or -o) gives the ordinal number
of the CSV row.  Also, for MODE of mix, when -k KEY is used, the pseudokey 
_KEY is available as output, and yields the md5 hash of the value of KEY
for that row (e.g., for -k experiment, the pseudokey is: _experiment).

Typical usage:
  util/select_ensembles.py -o experiment -k chars_earth_unique top sims/HabEx_4m_TSDDold_DD_TF17_promo6_20190123.exp/reduce-yield-plus.csv

'''

# turmon
#  jan 2019
#  dec 2025 (-t/-T, etc.)

from operator import itemgetter
import argparse
import sys
import hashlib
import os
import csv

# global verbosity mode, also usable for debugging print's
VERBOSITY = 0

########################################
###
###  Utility Functions
###
########################################

def load_csv(infile):
    # load the CSV
    info = []
    try:
        with open(infile, 'r') as csvfile:
            reader = csv.DictReader(csvfile, delimiter=',')
            for row in reader:
                info.append(row)
    except IOError:
        sys.stderr.write("Error: could not open `%s'.  Quitting." % infile)
        raise
    # (no conversion possible)
    if len(info) == 0: return info
    # find conversion (just string-to-number where possible)
    # (we just inspect the first row)
    c_func = {}
    for k in info[0].keys():
        try:
            float(info[0][k])
            c_func[k] = float
        except ValueError:
            c_func[k] = str
    # do the conversion
    new_info = []
    for index,row in enumerate(info):
        new_row = {}
        for k in row:
            new_row[k] = c_func[k](row[k])
        # some "experiment" fields have an initial space: remove it
        # (FIXME: why is reduce_drms.py inserting these spaces?)
        if 'experiment' in new_row:
            new_row['experiment'] = str.strip(new_row['experiment'])
        new_row['_index'] = index
        new_info.append(new_row)
    return new_info

def decorate(table, key):
    r'''Adds hashed value to table, in-place.'''
    for row in table:
        # ensure a string, then convert to bytes
        # note, repr(float) is the same between Py2/Py3, but str(float) is not
        val = repr(row[key]).encode()
        h = hashlib.md5()
        h.update(val)
        # hash as a hex string, so it can be output with -o if desired
        row['_' + key] = h.hexdigest()

def select(table, n, thresh_lo, thresh_hi, sortkey, reverse):
    # threshold the table first (if desired)
    #   takes [key <= thresh_lo] & [key > thresh_hi]
    #   if both are given
    if thresh_lo != '':
        table = [r for r in table if r[sortkey] <= thresh_lo]
    if thresh_hi != '':
        table = [r for r in table if r[sortkey] > thresh_hi]
    table_s = sorted(table, key=itemgetter(sortkey), reverse=reverse)
    return table_s[:min(n,len(table_s))]

def main(args):
    # load CSV
    table = load_csv(args.infile)
    # prevent special cases
    if args.n == 0 or len(table) == 0: return
    # handle the "n = -1" flag
    n_select = args.n if args.n >= 0 else len(table)
    # assign sort key
    if args.key:
        args.sortkey = args.key
    else:
        # default to first key
        args.sortkey = list(table[0].keys())[0]
    if args.sortkey not in table[0]:
        print("%s: Error: supplied sort key not in CSV." % args.progname, file=sys.stderr)
        sys.exit(1)
    # case analysis to handle selection mode
    if args.mode == 'mix':
        # decorate the table with a new key, _ + sortkey, which has the md5 hash of
        # the sortkey.  We will sort on the new key to get a "random" but stable
        # selection of rows.  (By stable, we mean that adding a new row in a subsequent
        # simulation run will not change the selection radically.)
        decorate(table, args.sortkey)
        args.sortkey = '_' + args.sortkey
        reverse = False # sort order does not matter in this case
    elif args.mode == 'bottom':
        reverse = False
    elif args.mode == 'top':
        reverse = True
    else:
        print("%s: Error: bad mode." % args.progname, file=sys.stderr)
        sys.exit(1)
    # select some rows
    table_s = select(table, n_select, args.t, args.T, args.sortkey, reverse)
    # do nothing if table is empty
    if len(table_s) == 0: return
    # assign output key -- error check now because decorate() added a key
    if args.outkey:
        outkey = args.outkey
    else:
        outkey = list(table[0].keys())[0]
    if outkey not in table_s[0]:
        print("%s: Error: requested output key not in CSV." % args.progname, file=sys.stderr)
        sys.exit(1)
    # output the requested key
    for row in table_s:
        print(row[outkey], end=args.terminator)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Select Ensembles from Experiment.  Print the selected keys to stdout.",
                                     epilog='')
    parser.add_argument('mode', metavar='MODE', help='mode: "top" or "mix"')
    parser.add_argument('infile', metavar='FILE', help='CSV file name (with columns for -k and -o)')
    parser.add_argument('-k', '--key', type=str, default='',
                            help='key for selection.')
    parser.add_argument('-o', type=str, default='',
                            dest='outkey', help='key for output.')
    parser.add_argument('-n', help='number of ensemble keys output, T for all, default = %(default)s',
                      type=str, dest='n_orig', default='10', metavar='N')
    parser.add_argument('-t', help='threshold value (key <= t), default = none',
                      type=str, dest='t_orig', default='', metavar='VAL')
    parser.add_argument('-T', help='threshold value (key > T), default = none',
                      type=str, dest='T_orig', default='', metavar='VAL')
    parser.add_argument('-S', help='Sandbox naming conventions', action='store_true', dest='sandbox',
                            default=False)
    parser.add_argument('-0', help='line terminator is \\0', action='store_true', dest='zero',
                            default=False)
    parser.add_argument('-q', help='quiet', action='store_true', dest='quiet',
                            default=False)
    parser.add_argument('-v', help='verbosity', action='count', dest='verbose',
                            default=0)
    args = parser.parse_args()
    
    VERBOSITY = args.verbose

    # program name, for convenience
    args.progname = os.path.basename(sys.argv[0])
    
    # ensure the named file/dir is readable
    if not os.access(args.infile, os.R_OK):
        if not args.quiet:
            print("%s: Error: Supplied input file `%s' is not readable." % (
                args.progname, args.infile), file=sys.stderr)
        sys.exit(0 if args.quiet else 1)

    # remap Scenario directory to file using Sandbox conventions
    if args.sandbox and os.path.isdir(args.infile):
        args.in_dir = str.rstrip(args.infile, '/')
        if args.in_dir.endswith(".exp") or args.in_dir.endswith(".fam"):
            args.infile = args.in_dir + "/reduce-yield-plus.csv"
        else:
            args.infile = args.in_dir + "/reduce-info.csv"
    else:
        # define this for consistency
        args.in_dir = os.path.dirname(args.infile)

    # what should terminate output lines?
    args.terminator = '\0' if args.zero else '\n'
    
    # n_orig = 'T' => n = -1 (as a flag for "everything")
    # n_orig converts to int => ensure >= 0
    # else, throw error
    if args.n_orig == 'T':
        args.n = -1
    else:
        try:
            args.n = int(args.n_orig)
        except ValueError:
            print('%s: Error: n must be an integer or "T".' % args.progname, file=sys.stderr)
            sys.exit(1)
        if args.n < 0:
            print('%s: Error: n must be nonnegative.' % args.progname, file=sys.stderr)
            sys.exit(1)
        
    # t_orig = '' and T_orig = '' => no thresholding (rely on -n)
    # if t_orig/T_orig convert to float => do so
    if args.t_orig:
        try:
            args.t = float(args.t_orig)
        except ValueError:
            # leave it as a string
            args.t = args.t_orig
    else:
        args.t = args.t_orig
    if args.T_orig:
        try:
            args.T = float(args.T_orig)
        except ValueError:
            # leave it as a string
            args.T = args.T_orig
    else:
        args.T = args.T_orig
        
    if args.mode not in ('mix', 'bottom', 'top'):
        print("%s: Error: MODE must be `mix' 'bottom' or `top'." % args.progname, file=sys.stderr)
        sys.exit(1)

    if not (os.access(args.infile, os.R_OK) and os.path.isfile(args.infile)):
        if not args.quiet:
            print("%s: Error: Supplied csv file `%s' is not readable." % (
                args.progname, args.infile), file=sys.stderr)
        sys.exit(0 if args.quiet else 1)

    main(args)
    sys.exit(0)
